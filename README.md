# Nettlebane

## A Warning

Algorithms and data structures here are academic in nature, and not (necessarily)
suited for performant applications. They are not guaranteed to be --- and are probably
guaranteed not to be --- concurrency-safe. They have not been benchmarked or necessarily
implemented beautifully or efficiently. If you would like to use these algorithms or
data structures, firstly, thank you; secondly, if you have any suggestions, I would love
to hear from you; thirdly, please do not feel unduly negativity towards an intentional
feeble effort. After all, the default action of not using a library does not compel you
to use libraries on anyone's account but your own. 

That said, please feel free to have a browse.

## Thoughts on Engineering Interviews

The purpose of the code here is to review data structures and algorithms for interviews. 
They are written in Golang (master), C++ (cpp), C (clang), Python3 (python3), Javascript
(js), Java (beans) Clojure (clojure), and Haskell (haskell).

It is the rather unassailable view of many working engineers that the qualifications 
of an individual to engage in the noble endeavours of software crafting should be mostly
judged by the ability to regurgitate algorithms and data structures in the context of
challenging software puzzles. While I do not agree with these views --- for
example, no CEO were to be made to recite formulas in corporate finance in the context
of sometimes obscure management case studies --- I am little able to influence the
entrenched thoughts of my generation. The battle against HR, mid-tier management and 
engineering authorities cannot be won on commonsense alone: Suppose a current 
incumbent fail to answer these questions, should we sack him? What portion of the 
life-cycle of product development consists of (without access to references) rolling
one's own Kruskal's algorithm?
